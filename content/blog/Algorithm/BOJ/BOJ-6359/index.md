---
title: "[백준] 6359번 만취한 상범 (C++)"
date: 2022-02-04 03:34:17
category: Algorithm/BOJ
description: "[ 🤎 BRONZE 2 ]"
---

[만취한 상범](https://www.acmicpc.net/problem/6359)

## 🌟 문제

서강대학교 곤자가 기숙사의 지하에는 n개의 방이 일렬로 늘어선 감옥이 있다. 각 방에는 벌점을 많이 받은 학생이 구금되어있다.

그러던 어느 날, 감옥 간수인 상범이는 지루한 나머지 정신나간 게임을 하기로 결정했다. 게임의 첫 번째 라운드에서 상범이는 위스키를 한 잔 들이키고, 달려가며 감옥을 한 개씩 모두 연다. 그 다음 라운드에서는 2, 4, 6, ... 번 방을 다시 잠그고, 세 번째 라운드에서는 3, 6, 9, ... 번 방이 열려있으면 잠그고, 잠겨있다면 연다. k번째 라운드에서는 번호가 k의 배수인 방이 열려 있으면 잠그고, 잠겨 있다면 연다. 이렇게 n번째 라운드까지 진행한 이후, 상범이는 위스키의 마지막 병을 마시고 쓰러져 잠든다.

구금되어있는 몇 명(어쩌면 0명)의 학생들은 자신의 방을 잠그지 않은 채 상범이가 쓰러져버렸단 것을 깨닫고 즉시 도망친다.

방의 개수가 주어졌을 때, 몇 명의 학생들이 도주할 수 있는지 알아보자.

## 🌟 입력

입력의 첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄에 한 개씩 방의 개수 n(5 ≤ n ≤ 100)이 주어진다.

## 🌟 출력

한 줄에 한 개씩 각 테스트 케이스의 답, 즉 몇 명이 탈출할 수 있는지를 출력한다.

## 🌟 풀이

복잡하게 생각할 필요 없다. 그냥... 반복문 중첩해서 구구단 구현해서 해당하는 방들 열었다 닫았다 해 주고 마지막까지 열려있는 방의 개수를 구해주면 된다. (설명하는 것 보다 코드를 보는게 더 쉬울 듯 하다.)

생각한 그대로를 코드로 구현할 수 있는지를 묻는 문제인 것 같다.

## 🌟 코드

````cpp
/*
2022-2-3
6359_만취한 상범
https://www.acmicpc.net/problem/6359
*/

#include <iostream>
using namespace std;

int t, n, cnt;
bool room[101];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> t;
	while (t--){
		cin >> n;
		// 초기화
		cnt = 0;
		for (int i = 1; i <= n; i++)
			room[i] = false;	// 잠금
		// 열려있으면 잠그기, 잠겨있으면 열기
		for(int k = 1; k <= n; k++){
			for(int i = 1; i * k <= n; i++){
				if (room[i * k])
					room[i * k] = false;
				else
					room[i * k] = true;
			}
		}
		// 열려있는 것 세어주기
		for(int i = 1; i <= n; i++){
			if (room[i])
				cnt++;
		}
		cout << cnt << '\n';
	}

	return (0);
}
````
